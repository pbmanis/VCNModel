#!/usr/bin/python
"""
Noise generator for GIF model training
"""
from __future__ import print_function
import numpy as np
import scipy.stats
import scipy.signal
import matplotlib.pyplot as plt



class NoiseGen():
    def __init__(self, mode='gauss', **kwds):
        """
        Create an instance of a noise generator
        
        Parameters
        ----------
        mode : str (default: 'gauss')
            Generator mode. Choices are gauss, skewed, or transformed. Transformed
            takes a gaussian distribution and passes it through a single 
        **kwds parameters:
        i0 : float (default: 0)
            DC current for noise signal
        amp : float (default: 1.0)
            Amplitude for output signal
        skew : float (default: 0.)
            Amount of skew to apply to amplitude distribution
            if 0, then the noise has a zero-mean (+i0) Gaussian amplitude distribution
            else, it is generated by skewnorm. 
        dt : float (default: 0.05)
            Sampling rate for noise signal, in msec (e.g., 50 usec)
        sigma0 : float (default: 2.0)
            standard deviation of the noise signal
        fmod : float (default: 0.2)
            Modulation frequence, in kHz
        dmod : float (default 1.0)
            Fractional modulation depth: 1.0 = 100% modulation
        tau : float (default: 3.0)
            Smoothing time constant (first order LPF, essenstially)
        dur : float (default: 10.0)
            Duration of the generated waveform, in seconds
        """
        
        self.mode = mode  # required"
        # dict defines all the valid parameters
        self.default_pars = {'i0': 0.0, 'amp':1.0, 'skew': 0.0, 'dt': 0.05,
                'sigma': 2.0, 'fmod': 1.0, 'dmod': 1.0, 'tau': 3.0,
                'dur': 10.0, 'transform': 'linear', 'mode': 'gauss'}
        self.reset_params()

    def set_params(self, **kwds):
        """
        Set any parameters by name that are in the self.pars dict
        
        Parameters
        ----------
        **kwds : keyword parameters that are defined in the dict.
        """
        
        for k in kwds:
            if k not in self.pars:
                raise ValueError('Paramter %s is not a valid parameter' % k)
            setattr(self, k, kwds[k])

    def reset_params(self):
        self.pars = sorted(self.default_pars.keys())  # save values for setting later
        for p in self.pars:
            setattr(self, p, self.default_pars[p])  # now class members
        
    def show_values(self):
        """
        Print out the current parameter values
        """
        for p in self.pars:
            if p == 'pars':  # skip the pars itself...
                continue
            print ("{0:>12s} = ".format(p), end='')
            print( self.__dict__[p])

    def generator(self):
        """
        Generate an amplitude modulated, low-pass filtered noise waveform with
        either a symmetrical Gaussian amplitude distribution (skew=0.), or a skewed amplitude
        distribution.

        Returns
        -------
        (tb, It) : tuple of numpy arrays
            Time base and current values
        """
    
        # compute all times
        tb = np.linspace(0, self.dur*1000., int(self.dur*1000./self.dt))
        It = np.zeros_like(tb)
        # compute how sigma varies over time:
        sigma = self.sigma*(1.0+self.dmod*(1.0-np.cos(2.0*np.pi*(self.fmod/1000.0)*tb)))

        rv = scipy.stats.skewnorm(self.skew)
        nrand = scipy.stats.skewnorm.rvs(self.skew, loc=self.i0, scale=self.amp, size=int(tb.shape[0]))
        sig = nrand * np.sqrt(2.0*(sigma*sigma))

        if self.transform == 'boltzmann':
            print('doing boltzmann')
            sig = self.boltz(sig, 0.1, 4.0)

        # low pass filter
        b, a = scipy.signal.butter(4, self.dt/self.tau, btype='low', analog=True)
        It = scipy.signal.lfilter(b, a, sig)
        scf = np.mean(sig/It)
        
        # shape to minimize trasients at beginning and end
        It = 10.*self.cos2window(tb, It)
        return(tb, It)

    def cos2window(self, tb, It, rampt=10.0):
        """
        Cos squared ramp with trise time of rampt
        Applied to first and last points in the waveform
        We use a Tukey window, but square the result.
        
        Parameters
        ----------
        tb: numpy array (no default)
            Holds the time base array
        It: numpy array (no default)
            Hods the calculated current waveform
        rampt : float (default : 5.0)
            Set the cos^2 rise/fall waveform time, in msec
        
        Returns
        -------
        It: shaped waveform
        """
        if rampt <= 0.:
            return It
        ntaper = int(2.0*rampt/self.dt)  # need to double rampt to get right time
        w = scipy.signal.windows.tukey(len(It), alpha=float(ntaper)/len(It), sym=True)
        w = w*w  # square it to round out the edges...
        return(It*w)
    
    def boltz(self, It, h, k):
        return 20./(1.0+np.exp(-(It-h)/k))
        
if __name__ == '__main__':
    NG = NoiseGen()  # create instance of the generator
    fig, ax = plt.subplots(3,2)
    dmod = 1
    i0 = 0.5
    tau=0.2
    NG.set_params(skew=0., dmod=dmod, i0=i0, tau=tau)  # parameters
    NG.show_values()  # just for testing
    
    # ix = np.linspace(-1.0, 1.0, 50)
    # z = NG.boltz(ix, -0., 1/10.)
    # f = plt.figure()
    # plt.plot(ix, z)
    # plt.show()
    
    # standard gaussian amplitude distribution
    tb, It = NG.generator()

    ax = ax.ravel()
    ax[0].plot(tb, It, 'k-', linewidth=0.5)
    # Amplitude histogram of the data
    n, bins, patches = ax[1].hist(It, 50, normed=1, facecolor='black', alpha=0.75)
    #l = plt.plot(bins, 'r--', linewidth=1)

    # skewed gaussian
    NG.set_params(skew=8.)  # just change the skew
    tbs, Its = NG.generator()
    ax[2].plot(tbs, Its, 'c-', linewidth=0.5)
    ax[2].set_ylabel('nA')
    n, bins, patches = ax[3].hist(Its, 50, normed=1, facecolor='cyan', alpha=0.75)
    ax[3].set_ylabel('density')
    # Normal Gaussian noise, but through a transform.
    # 
    NG.set_params(skew=0., transform='boltzmann')  # reset skew to 0,
    NG.show_values()
    tbs, Its = NG.generator()
    ax[4].plot(tbs, Its, 'b-', linewidth=0.5)
    ax[4].set_xlabel('Time (s)')
    n, bins, patches = ax[5].hist(Its, 50, normed=1, facecolor='blue', alpha=0.75)
    ax[5].set_xlabel('Amp (nA)')
    for axn in [1, 3, 5]:
        ax[axn].set_xlim([-1.5, 1.5])
    for axn in [0, 2, 4]:
        ax[axn].set_ylim([-1.5, 1.5])
    plt.show()
